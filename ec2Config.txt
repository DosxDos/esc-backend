#AWS DATA ROOT
    soporte@galagaagency.com
    Galagaagency2024*

#AWS DATA USER
    911167925263
    anfego1
    Abfe04**

#SSH HOST
    ec2-51-92-121-143.eu-south-2.compute.amazonaws.com
    ec2-user

#ARCHIVO DE VIRTUAL HOSTS DE APACHE

    sudo nano /etc/httpd/conf.d/my-vhost.conf

#ARCHIVO CONFIGURACIÓN DE APACHE

    sudo nano /etc/httpd/conf/httpd.conf

#VERIFICAR SINTAXIS APACHE

    sudo apachectl configtest

#REINICIAR APACHE

    sudo systemctl restart httpd

#DESCARTAR CAMBIOS GIT EN EL SERVIDOR
    
    sudo -u apache -s
    cd /var/www/html/esc-backend
    git checkout -- .
    git pull
    exit

#CONFIGURACIÓN INICIAL

    sudo yum update -y

    sudo yum install httpd -y

    sudo systemctl start httpd
    sudo systemctl enable httpd

    sudo yum install php php-mysqlnd php-gd php-xml -y

    sudo systemctl restart httpd

    echo "<?php phpinfo(); ?>" | sudo tee /var/www/html/info.php

    sudo yum install vsftpd -y

    sudo nano /etc/vsftpd/vsftpd.conf
    anonymous_enable=NO (para deshabilitar acceso anónimo).
    local_enable=YES (para permitir acceso a usuarios locales).
    write_enable=YES (para permitir escritura).
    chroot_local_user=YES
    allow_writeable_chroot=YES

    sudo adduser ftpuser
    sudo passwd ftpuser

    sudo chown -R ftpuser:ftpuser /var/www/html

    sudo systemctl start vsftpd
    sudo systemctl enable vsftpd

    sudo nano /etc/vsftpd/vsftpd.conf

pasv_enable=YES
pasv_min_port=1024
pasv_max_port=1048

pasv_address=51.92.121.143

local_root=/var/www/html
chroot_local_user=YES
allow_writeable_chroot=YES

    sudo setfacl -m u:ftpuser:rwx /var/www/html

    sudo systemctl restart vsftpd

    Permitir Conexiones FTP en el Grupo de Seguridad en el puerto 21 y en los puertos pasivos 1024-1048

    Abre FileZilla y usa las credenciales del usuario ftpuser y la IP pública de tu EC2 para conectarte.

#IP ELÁSTICA

    Crear IP elástica en AWS, para que la IP nunca cambie y se pueda servir los dominios

    sudo nano /etc/httpd/conf.d/my-vhost.conf

<VirtualHost *:80>
    DocumentRoot "/var/www/html"
    ServerName ec2-51-92-121-143.eu-south-2.compute.amazonaws.com

    <Directory "/var/www/html">
        Options Indexes FollowSymLinks
        AllowOverride All
        Require all granted
    </Directory>

    ErrorLog /var/log/httpd/my-vhost-error.log
    CustomLog /var/log/httpd/my-vhost-access.log combined
</VirtualHost>


#MYSQL DATABASE

    Crear base de datos en RDS.

    wget https://www.phpmyadmin.net/downloads/phpMyAdmin-latest-all-languages.tar.gz

    tar xzf phpMyAdmin-latest-all-languages.tar.gz
    sudo mv phpMyAdmin-*/ /var/www/html/phpmyadmin

    sudo chown -R apache:apache /var/www/html/phpmyadmin

    sudo nano /var/www/html/phpmyadmin/config.inc.php

<?php
/* phpMyAdmin configuración básica */
$i = 0;
$i++;
$cfg['blowfish_secret'] = 'Abfe04**Abfe04**Abfe04**Abfe04**'; /* Cambia esto por una cadena aleatoria */
$cfg['Servers'][$i]['auth_type'] = 'cookie';
$cfg['Servers'][$i]['host'] = 'escdb.cp6cs62ii5xo.eu-south-2.rds.amazonaws.com';
$cfg['Servers'][$i]['compress'] = false;
$cfg['Servers'][$i]['AllowNoPassword'] = false;
$cfg['Servers'][$i]['port'] = '3306';

/* Otras configuraciones */
$cfg['UploadDir'] = '';
$cfg['SaveDir'] = '';
?>

    sudo systemctl restart httpd

    http://ec2-51-92-121-143.eu-south-2.compute.amazonaws.com/phpmyadmin

EN PRODUCCIÓN: Restringir el Acceso a phpMyAdmin por IP

    sudo nano /etc/httpd/conf.d/phpMyAdmin.conf

<Directory /var/www/html/phpmyadmin>
Order Deny,Allow
Deny from all
Allow from 123.45.67.89  # Reemplaza esto con tu IP pública
</Directory>

#GITHUB

    sudo yum install git -y

    cd /var/www/html

    ssh-keygen -t ed25519 -C "anfego1@hotmail.com"

    Varias veces enter hasta crear la clave ssh

    cat ~/.ssh/id_ed25519.pub

    Copiar la clave ssh y crearla en GITHUB

    ssh -T git@github.com

    sudo chown -R ec2-user:ec2-user /var/www/html

    git clone git@github.com:DosxDos/esc-backend.git esc-backend

    nano /var/www/html/esc-backend/webhookgithub.php

    <?php
// Ruta del proyecto
$projectDir = '/var/www/html/esc-backend';

// Lee el payload de GitHub
$payload = file_get_contents('php://input');

// Verifica que el payload esté presente
if (!$payload) {
    http_response_code(400);
    die('Bad request: no payload received.');
}

// Ejecuta el comando de actualización del repositorio
$output = shell_exec("cd {$projectDir} && git pull 2>&1");
echo $output;
?>

    sudo visudo

#APACHE Y GITHUB
apache ALL=(ALL) NOPASSWD: /usr/bin/git

    #PERMISOS GENERALES Y GRUPO EN LA RAÍZ DE APACHE

    for user in $(cut -f1 -d: /etc/passwd); do
    sudo usermod -a -G apache $user
    done

    sudo chmod -R 775 /var/www/html

    sudo chmod g+s /var/www/html

    sudo mkdir /usr/share/httpd/.ssh
    sudo chown apache:apache /usr/share/httpd/.ssh
    sudo chmod 700 /usr/share/httpd/.ssh

    sudo cp /home/ec2-user/.ssh/id_ed25519 /usr/share/httpd/.ssh/
    sudo cp /home/ec2-user/.ssh/id_ed25519.pub /usr/share/httpd/.ssh/

    sudo chown apache:apache /usr/share/httpd/.ssh/id_ed25519
    sudo chown apache:apache /usr/share/httpd/.ssh/id_ed25519.pub
    sudo chmod 600 /usr/share/httpd/.ssh/id_ed25519
    sudo chmod 644 /usr/share/httpd/.ssh/id_ed25519.pub

    sudo -u apache ssh -T git@github.com

    sudo -u apache -s

    cd /var/www/html/esc-backend

    git pull

    crear el webhook en el repositorio de GITHUB con el archivo php:

    http://ec2-51-92-121-143.eu-south-2.compute.amazonaws.com/esc-backend/webhookgithub.php

CONFLICTOS (DESCARTAR)
    git checkout -- webhookgithub.php
    git pull

CONFLICTOS (ELIMINAR)
    rm webhookgithub.php
    git pull

#SSL

    Comprar dominio

    Solicita un Certificado en AWS Certificate Manager (ACM)

    Ve a la consola de AWS Certificate Manager (ACM).
    Haz clic en Request a certificate.
    Selecciona Request a public certificate y haz clic en Next.
    Ingresa tu dominio (e.g., yourdomain.com) y cualquier subdominio que quieras cubrir (e.g., www.yourdomain.com).
    Elige el método de validación. Te recomiendo DNS validation, ya que es rápido y una vez configurado, el certificado se renovará automáticamente.
    ACM te proporcionará un CNAME que debes agregar a tu Hosted Zone en Route 53. Haz esto para validar tu dominio. - Crear el registro con el botón de crear del AWS para que funcione
    Configura un Elastic Load Balancer (ELB)

    AWS no permite adjuntar directamente un certificado ACM a una instancia EC2; necesitas un Elastic Load Balancer (ELB) para manejar el tráfico HTTPS. El ELB actuará como un proxy y redirigirá el tráfico a tu instancia EC2:

    Ve a la consola de EC2 y selecciona Load Balancers en el panel de navegación.
    Haz clic en Create Load Balancer y selecciona Application Load Balancer (ideal para aplicaciones web).
    Configura el nombre del load balancer y selecciona Internet-facing para que sea accesible desde internet.
    En Listeners, asegúrate de que esté seleccionado HTTP (80) y HTTPS (443).
    Selecciona tus subnets y security groups (el security group debe permitir tráfico en los puertos 80 y 443).
    En Secure listener settings, selecciona el certificado que creaste en ACM.
    Configura el Target Group para redirigir el tráfico a tu instancia EC2. Selecciona Instance como tipo de destino y añade tu instancia EC2 al target group.

    En tu Hosted Zone de Route 53, crea un nuevo registro A.
    Selecciona Alias y en el Alias Target, elige tu Load Balancer.
    De esta manera, tu dominio apuntará al ELB que manejará las conexiones HTTPS y las redirigirá a tu instancia.
    Ventajas de Este Método
    Renovación Automática: AWS ACM renovará automáticamente el certificado sin que tú tengas que intervenir.
    Manejo Seguro de Tráfico: El ELB se encarga de la terminación SSL, garantizando que las conexiones entre tus usuarios y el ELB estén siempre seguras.
    Escalabilidad: Si en el futuro necesitas escalar tu aplicación, el ELB facilitará añadir más instancias EC2 sin cambiar la configuración de dominio o SSL.
    Con estos pasos, tendrás un certificado SSL gestionado por AWS y renovado automáticamente, manteniendo tus conexiones seguras.

    Ajusta tu Apache para Usar el Load Balancer:

    sudo nano /etc/httpd/conf.d/my-vhost.conf


<VirtualHost *:80>
    ServerName app-energiasolarcanarias-backend.com
    DocumentRoot /var/www/html/esc-backend

    <Directory "/var/www/html/esc-backend">
        Options Indexes FollowSymLinks
        AllowOverride All
        Require all granted
    </Directory>

    ErrorLog /var/log/httpd/app-energiasolarcanarias-error.log
    CustomLog /var/log/httpd/app-energiasolarcanarias-access.log combined
</VirtualHost>
<VirtualHost *:80>
    ServerName www.app-energiasolarcanarias-backend.com
    DocumentRoot /var/www/html/esc-backend

    <Directory "/var/www/html/esc-backend">
        Options Indexes FollowSymLinks
        AllowOverride All
        Require all granted
    </Directory>

    ErrorLog /var/log/httpd/app-energiasolarcanarias-error.log
    CustomLog /var/log/httpd/app-energiasolarcanarias-access.log combined
</VirtualHost>

    sudo systemctl restart httpd

#CORS 

    Se debe poner a apache como propietario de la raíz del servidor:

    sudo chown -R apache:apache /var/www/html

    sudo chmod -R 755 /var/www/html

    sudo nano /etc/httpd/conf/httpd.conf

IncludeOptional conf.d/*.conf
<Directory "/var/www/html/esc-backend">
    Header always set Access-Control-Allow-Origin "*"
    Header always set Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS"
    Header always set Access-Control-Allow-Headers "Origin, X-Requested-With, Content-Type, Accept, Authorization, usuario, apiKey"
    Header always set Access-Control-Allow-Credentials "true"
    RewriteEngine On
    RewriteCond %{REQUEST_METHOD} OPTIONS
    RewriteRule ^(.*)$ $1 [R=200,L]
</Directory>
